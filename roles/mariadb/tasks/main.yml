---
# tasks file for mariadb
# Purpose: Database automation per domain — idempotent design
#
# IDEMPOTENCY STRATEGY
# ────────────────────
# mysql_db  / mysql_user with state=present are idempotent by design:
# the module queries information_schema / mysql.user BEFORE acting and
# only emits changed=true when it actually created or altered the entity.
#
# On top of that we add an explicit pre-flight query layer:
#   1. Query existing databases / users with mysql_query  → register results
#   2. Build "what is missing" lists with set_fact + Jinja2
#   3. Feed only the missing entries into mysql_db / mysql_user
#   4. Verification tasks at the end use changed_when: false so they never
#      pollute the changed count even when they run on every play.
#
# CONDITIONAL FLAGS (set in group_vars or host_vars, all default false):
#   mariadb_create_databases  — run database provisioning block
#   mariadb_create_users      — run user provisioning block
#   mariadb_save_credentials  — write credential files to user homes
#   mariadb_apply_config      — push performance tuning template (default true)
#   mariadb_allow_remote      — open MySQL port in firewalld

# =============================================================================
# INSTALL & SERVICE
# =============================================================================

- name: Install MariaDB packages
  ansible.builtin.dnf:
    name:
      - mariadb-server
      - mariadb
      - python3-PyMySQL
    state: present
  tags: [mariadb, install]

- name: Enable and start MariaDB service
  ansible.builtin.systemd:
    name: mariadb
    state: started
    enabled: true
  tags: [mariadb, service]

# =============================================================================
# SECURITY HARDENING
# =============================================================================

- name: Check if MariaDB root has no password yet
  ansible.builtin.command: mysql -u root -e "SELECT 1"
  register: _mariadb_root_open
  changed_when: false        # pure read — never counts as a change
  failed_when: false
  tags: [mariadb, security]

- name: Set root password (only when socket auth has no password)
  community.mysql.mysql_user:
    name: root
    password: "{{ mariadb_root_password }}"
    login_unix_socket: /var/lib/mysql/mysql.sock
    state: present
  when: _mariadb_root_open.rc == 0
  no_log: true
  tags: [mariadb, security]

- name: Deploy /root/.my.cnf for passwordless CLI access
  ansible.builtin.template:
    src: my.cnf.j2
    dest: /root/.my.cnf
    owner: root
    group: root
    mode: '0600'
  no_log: true
  tags: [mariadb, security]

- name: Remove anonymous users
  community.mysql.mysql_user:
    name: ''
    host_all: true
    state: absent
    login_user: root
    login_password: "{{ mariadb_root_password }}"
  no_log: true
  tags: [mariadb, security]

- name: Remove test database
  community.mysql.mysql_db:
    name: test
    state: absent
    login_user: root
    login_password: "{{ mariadb_root_password }}"
  tags: [mariadb, security]

- name: Disallow remote root login
  community.mysql.mysql_query:
    login_user: root
    login_password: "{{ mariadb_root_password }}"
    query: >
      DELETE FROM mysql.user
      WHERE User='root'
      AND Host NOT IN ('localhost', '127.0.0.1', '::1')
  changed_when: false        # DELETE 0 rows on re-run — not a real change
  no_log: true
  tags: [mariadb, security]

# =============================================================================
# BUILD FLAT ENTRY LISTS  (both blocks need these)
# =============================================================================
# subelements() only accepts a single top-level key; it cannot traverse a
# dotted path.  We materialise two flat lists with Jinja2 for-loops instead:
#
#   domain_entries    → [{username, domain, db_name, db_user}, …]
#   subdomain_entries → [{username, domain, subdomain, db_name, db_user}, …]
#
# db_name and db_user are pre-computed here so every subsequent task can
# reference them by name without repeating the regex/truncate logic.

- name: Build flat domain entry list
  ansible.builtin.set_fact:
    domain_entries: >-
      {%- set max_len = mariadb_username_max_length | int -%}
      {%- set result = [] -%}
      {%- for user in hosting_users -%}
        {%- for dom in user.domains | default([]) -%}
          {%- set db_name = (user.username ~ '_' ~ dom.domain)
                            | regex_replace('[^a-zA-Z0-9]', '_') -%}
          {%- set db_user = db_name[:max_len] -%}
          {%- set _ = result.append({
                'username': user.username,
                'domain':   dom.domain,
                'db_name':  db_name,
                'db_user':  db_user
              }) -%}
        {%- endfor -%}
      {%- endfor -%}
      {{ result }}
  tags: [always]

- name: Build flat subdomain entry list
  ansible.builtin.set_fact:
    subdomain_entries: >-
      {%- set max_len = mariadb_username_max_length | int -%}
      {%- set result = [] -%}
      {%- for user in hosting_users -%}
        {%- for dom in user.domains | default([]) -%}
          {%- for sub in dom.subdomains | default([]) -%}
            {%- set db_name = (user.username ~ '_' ~ sub ~ '_' ~ dom.domain)
                              | regex_replace('[^a-zA-Z0-9]', '_') -%}
            {%- set db_user = db_name[:max_len] -%}
            {%- set _ = result.append({
                  'username':  user.username,
                  'domain':    dom.domain,
                  'subdomain': sub,
                  'db_name':   db_name,
                  'db_user':   db_user
                }) -%}
          {%- endfor -%}
        {%- endfor -%}
      {%- endfor -%}
      {{ result }}
  tags: [always]

# =============================================================================
# VALIDATE USERNAME LENGTH  (fail fast before any DB work)
# =============================================================================
# Assert every db_user computed in the entry lists respects the configured
# limit.  Runs before any query or create task so operators see a clear
# message instead of a cryptic MySQL error.

- name: Assert all domain db_user values are within max length
  ansible.builtin.assert:
    that:
      - item.db_user | length <= mariadb_username_max_length | int
    fail_msg: >-
      db_user '{{ item.db_user }}' is {{ item.db_user | length }} chars —
      exceeds mariadb_username_max_length={{ mariadb_username_max_length }}.
      Shorten username '{{ item.username }}' or the domain name, or increase
      mariadb_username_max_length in defaults/main.yml (MariaDB >= 10.6 supports 80).
    success_msg: "db_user '{{ item.db_user }}' ({{ item.db_user | length }} chars) ✓"
  loop: "{{ domain_entries + subdomain_entries }}"
  loop_control:
    label: "{{ item.db_user }} ({{ item.db_user | length }} chars)"
  tags: [mariadb, validate]

# =============================================================================
# PASSWORD GENERATION STRATEGY (FILE-BASED IDEMPOTENCY)
# =============================================================================

- name: Check if domain database credentials files exist
  ansible.builtin.stat:
    path: "/home/{{ item.username }}/db-credentials-{{ item.db_name }}.txt"
  loop: "{{ domain_entries }}"
  register: _domain_creds_stat
  loop_control:
    label: "{{ item.username }} / {{ item.db_name }}"
  tags: [mariadb, users]

- name: Generate passwords ONLY for new domain users (file missing)
  ansible.builtin.set_fact:
    domain_db_passwords: >-
      {{ domain_db_passwords | default({}) | combine({
           item.item.db_user: lookup('password', '/dev/null length=32 chars=ascii_letters,digits')
         }) }}
  loop: "{{ _domain_creds_stat.results }}"
  loop_control:
    label: "{{ item.item.db_user }}"
  when:
    - mariadb_create_users | bool
    - not item.stat.exists  # Hanya generate jika file BELUM ada
  no_log: true
  tags: [mariadb, users]

- name: Check if subdomain database credentials files exist
  ansible.builtin.stat:
    path: "/home/{{ item.username }}/db-credentials-{{ item.db_name }}.txt"
  loop: "{{ subdomain_entries }}"
  register: _subdomain_creds_stat
  loop_control:
    label: "{{ item.username }} / {{ item.db_name }}"
  tags: [mariadb, users]

- name: Generate passwords ONLY for new subdomain users (file missing)
  ansible.builtin.set_fact:
    subdomain_db_passwords: >-
      {{ subdomain_db_passwords | default({}) | combine({
           item.item.db_user: lookup('password', '/dev/null length=32 chars=ascii_letters,digits')
         }) }}
  loop: "{{ _subdomain_creds_stat.results }}"
  loop_control:
    label: "{{ item.item.db_user }}"
  when:
    - mariadb_create_users | bool
    - not item.stat.exists # Hanya generate jika file BELUM ada
  no_log: true
  tags: [mariadb, users]

# =============================================================================
# DATABASE & USER PROVISIONING
# =============================================================================

- name: "[DB] Ensure domain databases exist"
  community.mysql.mysql_db:
    name: "{{ item.db_name }}"
    state: present
    login_user: root
    login_password: "{{ mariadb_root_password }}"
    collation: utf8mb4_unicode_ci
    encoding: utf8mb4
  loop: "{{ domain_entries }}"
  loop_control:
    label: "{{ item.db_name }}"
  when: mariadb_create_databases | bool
  tags: [mariadb, databases]

- name: "[DB] Ensure subdomain databases exist"
  community.mysql.mysql_db:
    name: "{{ item.db_name }}"
    state: present
    login_user: root
    login_password: "{{ mariadb_root_password }}"
    collation: utf8mb4_unicode_ci
    encoding: utf8mb4
  loop: "{{ subdomain_entries }}"
  loop_control:
    label: "{{ item.db_name }}"
  when: mariadb_create_databases | bool
  tags: [mariadb, databases]

- name: "[USER] Ensure domain users exist"
  community.mysql.mysql_user:
    name: "{{ item.db_user }}"
    password: "{{ domain_db_passwords[item.db_user] | default(omit) }}"
    priv: "{{ item.db_name }}.*:ALL"
    host: localhost
    state: present
    login_user: root
    login_password: "{{ mariadb_root_password }}"
  loop: "{{ domain_entries }}"
  loop_control:
    label: "{{ item.db_user }} → {{ item.db_name }}"
  when: mariadb_create_users | bool
  no_log: true
  tags: [mariadb, users]

- name: "[USER] Ensure subdomain users exist"
  community.mysql.mysql_user:
    name: "{{ item.db_user }}"
    password: "{{ subdomain_db_passwords[item.db_user] | default(omit) }}"
    priv: "{{ item.db_name }}.*:ALL"
    host: localhost
    state: present
    login_user: root
    login_password: "{{ mariadb_root_password }}"
  loop: "{{ subdomain_entries }}"
  loop_control:
    label: "{{ item.db_user }} → {{ item.db_name }}"
  when: mariadb_create_users | bool
  no_log: true
  tags: [mariadb, users]

# =============================================================================
# SAVE CREDENTIALS
# =============================================================================

- name: Save domain database credentials to user home
  ansible.builtin.template:
    src: db-credentials.txt.j2
    dest: "/home/{{ item.username }}/db-credentials-{{ item.db_name }}.txt"
    owner: "{{ item.username }}"
    group: "{{ item.username }}"
    mode: '0600'
  loop: "{{ domain_entries }}"
  loop_control:
    label: "{{ item.username }} / {{ item.db_name }}"
  when:
    - mariadb_save_credentials | bool
    - domain_db_passwords[item.db_user] is defined
  tags: [mariadb, credentials]

- name: Save subdomain database credentials to user home
  ansible.builtin.template:
    src: db-credentials-subdomain.txt.j2
    dest: "/home/{{ item.username }}/db-credentials-{{ item.db_name }}.txt"
    owner: "{{ item.username }}"
    group: "{{ item.username }}"
    mode: '0600'
  loop: "{{ subdomain_entries }}"
  loop_control:
    label: "{{ item.username }} / {{ item.db_name }}"
  when:
    - mariadb_save_credentials | bool
    - subdomain_db_passwords[item.db_user] is defined
  tags: [mariadb, credentials]

# =============================================================================
# MANUAL DATABASE & USER DEFINITIONS  (from mariadb_databases / mariadb_users)
# =============================================================================
# These tasks process databases and users defined manually in group_vars or
# host_vars — independent of the hosting_users structure.
# Typical use: admin databases, monitoring, backups, or non-web applications.

- name: "[MANUAL] Create manually-defined databases"
  community.mysql.mysql_db:
    name: "{{ item.name }}"
    state: present
    collation: "{{ item.collation | default('utf8mb4_unicode_ci') }}"
    encoding: "{{ item.encoding | default('utf8mb4') }}"
    login_user: root
    login_password: "{{ mariadb_root_password }}"
  loop: "{{ mariadb_databases }}"
  loop_control:
    label: "{{ item.name }}"
  when: mariadb_databases | length > 0
  tags: [mariadb, manual, databases]

- name: "[MANUAL] Create manually-defined users with privileges"
  community.mysql.mysql_user:
    name: "{{ item.name }}"
    password: "{{ item.password }}"
    priv: "{{ item.priv }}"
    host: "{{ item.host | default('localhost') }}"
    state: present
    login_user: root
    login_password: "{{ mariadb_root_password }}"
  loop: "{{ mariadb_users }}"
  loop_control:
    label: "{{ item.name }}@{{ item.host | default('localhost') }} → {{ item.priv }}"
  when: mariadb_users | length > 0
  no_log: true
  tags: [mariadb, manual, users]

# =============================================================================
# VERIFY  (always runs — changed_when: false throughout)
# =============================================================================
# These tasks re-query the server and show what exists.  Because every task
# in this block carries changed_when: false the play never reports changed=N
# for verification steps — the output is always clean.

- name: "[VERIFY] Re-query existing databases after provisioning"
  community.mysql.mysql_query:
    login_user: root
    login_password: "{{ mariadb_root_password }}"
    query: >
      SELECT SCHEMA_NAME AS db
      FROM information_schema.SCHEMATA
      WHERE SCHEMA_NAME NOT IN ('information_schema','mysql','performance_schema','sys')
      ORDER BY SCHEMA_NAME
  register: _verify_databases
  changed_when: false
  tags: [mariadb, verify]

- name: "[VERIFY] Re-query existing users after provisioning"
  community.mysql.mysql_query:
    login_user: root
    login_password: "{{ mariadb_root_password }}"
    query: >
      SELECT User, Host
      FROM mysql.user
      WHERE User NOT IN ('root','mysql','mariadb.sys','')
      ORDER BY User
  register: _verify_users
  changed_when: false
  tags: [mariadb, verify]

- name: "[VERIFY] Display provisioned databases"
  ansible.builtin.debug:
    msg: |
      ── Databases present on {{ inventory_hostname }} ────────
      {% for row in _verify_databases.query_result %}
        ✓  {{ row[0] }}
      {% else %}
        (none — provision with mariadb_create_databases: true)
      {% endfor %}
      ─────────────────────────────────────────────────────────
  changed_when: false
  tags: [mariadb, verify]

- name: "[VERIFY] Display provisioned users"
  ansible.builtin.debug:
    msg: |
      ── Users present on {{ inventory_hostname }} ────────────
      {% for row in _verify_users.query_result %}
        ✓  {{ row[0] }}@{{ row[1] }}
      {% else %}
        (none — provision with mariadb_create_users: true)
      {% endfor %}
      ─────────────────────────────────────────────────────────
  changed_when: false
  tags: [mariadb, verify]

# =============================================================================
# PERFORMANCE TUNING  (guarded by mariadb_apply_config flag)
# =============================================================================

- name: Deploy MariaDB performance tuning config
  ansible.builtin.template:
    src: mariadb-custom.cnf.j2
    dest: /etc/my.cnf.d/99-custom.cnf
    owner: root
    group: root
    mode: '0644'
  when: mariadb_apply_config | bool
  notify: restart mariadb
  tags: [mariadb, config]

# =============================================================================
# FIREWALL
# =============================================================================

- name: Manage MySQL firewall rule
  ansible.posix.firewalld:
    service: mysql
    permanent: true
    state: "{{ mariadb_allow_remote | bool | ternary('enabled', 'disabled') }}"
    immediate: true
  when: ansible_facts.services['firewalld.service'] is defined
  tags: [mariadb, firewall]
